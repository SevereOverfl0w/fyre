#!/bin/sh
#
# wildefyr - 2016 (c) MIT
# default functions and variables for fyre scripts

    # environment files
###############################################################################

FYREDIR=${FYREDIR:-~/.config/fyre}
GROUPSDIR=${GROUPSDIR:-$FYREDIR/groups}
LAYOUTDIR=${LAYOUTDIR:-$FYREDIR/layouts}
test ! -d "$GROUPSDIR" && mkdir -p "$GROUPSDIR"
test ! -d "$LAYOUTDIR" && mkdir -p "$LAYOUTDIR"

HOVER=${HOVER:-$FYREDIR/hover}
FSFILE=${FSFILE:-$FYREDIR/fullinfo}
SCREENS=${SCREENS:-$FYREDIR/screens}
WIDLOCK=${WIDLOCK:-$FYREDIR/.widlock}

    # source user settings
###############################################################################

test -f $FYREDIR/config && {
    . $FYREDIR/config
} || {
    printf '%s\n' "No file found in default $FYREDIR location. See config.example"
    pkill xinit
}

    # functions
###############################################################################

intCheck() {
    test $1 -ne 0 2> /dev/null
    test $? -ne 2 || return 1
}

name() {
    test $# -eq 0 && return 1
    for wid in $@; do
        lsw -a | grep -q "$wid" && {
            xprop -id "$wid" WM_CLASS | cut -d\" -f 2
            unset -v wid
        } || {
            printf '%s\n' "Please enter a valid window id." >&2
            unset -v wid
            return 1
        }
    done
}

class() {
    test $# -eq 0 && return 1
    for wid in $@; do
        lsw -a | grep -q "$wid" && {
            xprop -id "$wid" WM_CLASS | cut -d\" -f 4
            unset -v wid
        } || {
            printf '%s\n' "Please enter a valid window id." >&2
            unset -v wid
            return 1
        }
    done
}

process() {
    test $# -eq 0 && return 1
    for wid in $@; do
        lsw -a | grep -q "$wid" && {
            xprop -id "$wid" _NET_WM_PID | cut -d\  -f 3
            unset -v wid
        } || {
            printf '%s\n' "Please enter a valid window id." >&2
            unset -v wid
            return 1
        }
    done
}

resolution() {
    wattr "$1" && {
        wid=$1
    } || {
        printf '%s\n' "Please enter a valid mpv window id." >&2
        return 1
    }

    test "$(class $wid)" = "mpv" && {
        resolution=$(xprop -id "$wid" WM_NORMAL_HINTS | \
            sed '5s/[^0-9]*//p;d' | tr / \ )
        printf '%s\n' "$resolution"
        unset -v wid resolution
    } || {
        printf '%s\n' "Please enter a valid mpv window id." >&2
        unset -v wid
        return 1
    }
}

generateScreenInfo() {
    test -f "$SCREENS" && rm -f "$SCREENS"

    type xrandr 2>&1 > /dev/null && {
        xrandr | grep -w 'connected' | while read -r connected; do
            screen=$(printf '%s\n' "$connected" | cut -d\  -f 1)
            geometry=$(printf '%s\n' "$connected" | cut -d\  -f 3)
            screenX="$(printf '%s\n' "$geometry" | cut -d'+' -f 2)"
            screenY="$(printf '%s\n' "$geometry" | cut -d'+' -f 3)"
            screenW="$(printf '%s\n' "$geometry" | cut -d'x' -f 1)"
            screenH="$(printf '%s\n' "$geometry" | cut -d'x' -f 2 | cut -d'+' -f 1)"
            printf '%s\n' "$screen $screenX $screenY $screenW $screenH" >> "$SCREENS"
        done

        unset -v screen screenX screenY screenW screenH geometry
    } || {
        # who doesn't use xrandr at this point?!
        printf '%s\n' "xrandr was not found on your \$PATH." >&2
        printf '%s\n' "multi-monitor detection will not work." >&2
        return 1
    }
}

findCurrentScreen() {
    for monitor in $(wc -l < "$SCREENS"); do
        monitorInfo="$(sed "/$monitor/!d" "$SCREENS")"

        # get monitor co-ordinates
        monitorX=$(printf '%s\n' "$monitorInfo" | cut -d\  -f 2)
        monitorY=$(printf '%s\n' "$monitorInfo" | cut -d\  -f 3)
        monitorW=$(printf '%s\n' "$monitorInfo" | cut -d\  -f 4)
        monitorH=$(printf '%s\n' "$monitorInfo" | cut -d\  -f 5)

        # test if current window X and Y value is focused on a window
        test $X -lt $monitorX && continue
        test $Y -lt $monitorY && continue
        test $X -gt $monitorW && continue
        test $Y -gt $monitorH && continue

        SCREEN=$monitor
        break
    done
}

# get correct SW and SH of current screen
retrieveScreenValues() {
    test ! -f "$SCREENS" && {
        generateScreenInfo || {
            ROOT="$(lsw -r)"
            SW=$(wattr w "$ROOT")
            SH=$(wattr h "$ROOT")
            unset -v ROOT
            return 1
        }
    }

    # if no window is focused, presume we want to operate on the first screen
    test -z $X && test -z $Y && {
        SW=$(sed "1!d" "$SCREENS" | cut -d\  -f 4)
        SH=$(sed "1!d" "$SCREENS" | cut -d\  -f 5)
        return 1
    }

    test $1 -ne 0 2> /dev/null && test $1 -le $(wc -l < $SCREENS) && {
        SCREEN=$1
    } || {
        findCurrentScreen
    }

    # get current screen X Y W H
    SCREENSTRING=$(sed "/$SCREEN/!d" "$SCREENS")
    SX=$(printf '%s\n' "$SCREENSTRING" | cut -d\  -f 2)
    SY=$(printf '%s\n' "$SCREENSTRING" | cut -d\  -f 3)
    SW=$(printf '%s\n' "$SCREENSTRING" | cut -d\  -f 4)
    SH=$(printf '%s\n' "$SCREENSTRING" | cut -d\  -f 5)

    # calculate variables for the new monitor
    eSW=$((SW - 2*XGAP))
    eSH=$((SH - TGAP - BGAP))
    minW=$((eSW/COLS - $((COLS - 1))*IGAP/COLS))
    minH=$((eSH/ROWS - $((ROWS - 1))*VGAP/ROWS))

    unset -v screenX screenY screenW screenH
}

# test if a point is over the top of a window
underneath() {
    test $# -eq 0 && {
        X=$(wmp | cut -d\  -f 1)
        Y=$(wmp | cut -d\  -f 2)
    } || {
        intCheck $1 && X=$1 || return 1
        intCheck $2 && Y=$2 || return 1
    }

    # start from the highest stacked window
    for wid in $(lsw | tac); do
        windowX=$(wattr x "$wid")
        windowY=$(wattr y "$wid")

        # we won't get a match if the left and top edges greater than X or Y
        test $windowX -gt $X && continue
        test $windowY -gt $Y && continue

        windowW=$(wattr w "$wid")
        windowH=$(wattr h "$wid")

        # we won't get a match if the right and bottom edges are less than X or Y
        test $((windowX + windowW)) -lt $X && continue
        test $((windowY + windowH)) -lt $Y && continue

        printf '%s\n' "$wid"
        unset -v wid
        return 0
    done
}

    # window management
###############################################################################

PFW="$(pfw)"
CUR=${2:-"$(pfw)"}

X=$(wattr x "$CUR" 2> /dev/null)
Y=$(wattr y "$CUR" 2> /dev/null)
W=$(wattr w "$CUR" 2> /dev/null)
H=$(wattr h "$CUR" 2> /dev/null)

# multiple monitor support
retrieveScreenValues
