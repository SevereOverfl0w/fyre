#!/bin/sh
#
# wildefyr - 2016 (c) MIT
# source file for fyre

    # environment files
###############################################################################

FYREDIR=${FYREDIR:-~/.config/fyre}
GROUPSDIR=${GROUPSDIR:-$FYREDIR/groups}
LAYOUTDIR=${LAYOUTDIR:-$FYREDIR/layouts}
test ! -d "$GROUPSDIR" && mkdir -p "$GROUPSDIR"
test ! -d "$LAYOUTDIR" && mkdir -p "$LAYOUTDIR"

HOVER=${HOVER:-$FYREDIR/hover}
IGNORE=${IGNORE:-$FYREDIR/ignored}
FSFILE=${FSFILE:-$FYREDIR/fullinfo}
SCREENS=${SCREENS:-$FYREDIR/screens}
WIDLOCK=${WIDLOCK:-$FYREDIR/.widlock}

    # functions
###############################################################################

intCheck() {
    test $1 -ne 0 2> /dev/null
    test $? -ne 2 || {
         printf '%s\n' "'$1' is not an integer." >&2
         exit 1
    }
}

name() {
    test $# -eq 0 && return 1
    for wid in $@; do
        lsw -a | grep -q "$wid" && {
            xprop -id "$wid" WM_CLASS | cut -d\" -f 2
            unset -v wid
        } || {
            printf '%s\n' "Please enter a valid window id." >&2
            unset -v wid
            return 1
        }
    done
}

class() {
    test $# -eq 0 && return 1
    for wid in $@; do
        lsw -a | grep -q "$wid" && {
            xprop -id "$wid" WM_CLASS | cut -d\" -f 4
            unset -v wid
        } || {
            printf '%s\n' "Please enter a valid window id." >&2
            unset -v wid
            return 1
        }
    done
}

process() {
    test $# -eq 0 && return 1
    for wid in $@; do
        lsw -a | grep -q "$wid" && {
            xprop -id "$wid" _NET_WM_PID | cut -d\  -f 3
            unset -v wid
        } || {
            printf '%s\n' "Please enter a valid window id." >&2
            unset -v wid
            return 1
        }
    done
}

resolution() {
    wattr "$1" && {
        wid=$1
    } || {
        printf '%s\n' "Please enter a valid mpv window id." >&2
        return 1
    }

    test "$(class $wid)" = "mpv" && {
        resolution=$(xprop -id "$wid" WM_NORMAL_HINTS | \
            sed '5s/[^0-9]*//p;d' | tr / \ )
        printf '%s\n' "$resolution"
        unset -v wid resolution
    } || {
        printf '%s\n' "Please enter a valid mpv window id." >&2
        unset -v wid
        return 1
    }
}

generateScreenInfo() {
    test -f "$SCREENS" && rm -f "$SCREENS"

    type xrandr 2>&1 > /dev/null && {
        xrandr | grep -w 'connected' | while read -r connected; do
            screen=$(printf '%s\n' "$connected" | cut -d\  -f 1)
            geometry=$(printf '%s\n' "$connected" | cut -d\  -f 3)
            screenX="$(printf '%s\n' "$geometry" | cut -d'+' -f 2)"
            screenY="$(printf '%s\n' "$geometry" | cut -d'+' -f 3)"
            screenW="$(printf '%s\n' "$geometry" | cut -d'x' -f 1)"
            screenH="$(printf '%s\n' "$geometry" | cut -d'x' -f 2 | cut -d'+' -f 1)"
            printf '%s\n' "$screen $screenX $screenY $screenW $screenH" >> "$SCREENS"
        done

        unset -v screen screenX screenY screenW screenH geometry
    } || {
        printf '%s\n' "xrandr was not found on your \$PATH." >&2
        printf '%s\n' "multi-monitor detection will not work." >&2
        return 1
    }
}

# return the current screen number
getCurrentScreen() {
    test ! -f "$SCREENS" && {
        generateScreenInfo || {
            printf '%s\n' "1"
            return 1
        }
    }

    CUR=${2:-"$(pfw)"}
    X=$(wattr x "$CUR" 2> /dev/null)
    Y=$(wattr y "$CUR" 2> /dev/null)

    for screen in $(wc -l < "$SCREENS"); do
        screenInfo="$(sed "/$screen/!d" "$SCREENS")"

        screenX=$(printf '%s\n' "$screenInfo" | cut -d\  -f 2)
        screenY=$(printf '%s\n' "$screenInfo" | cut -d\  -f 3)
        screenW=$(printf '%s\n' "$screenInfo" | cut -d\  -f 4)
        screenH=$(printf '%s\n' "$screenInfo" | cut -d\  -f 5)

        test $X -lt $screenX && continue
        test $Y -lt $screenY && continue
        test $X -gt $screenW && continue
        test $Y -gt $screenH && continue

        printf '%s\n' "$screen"
        unset -v screen screenX screenY screenW screenH
        return 0
    done
}

# get correct SW and SH of current screen
retrieveScreenValues() {
    test ! -f "$SCREENS" && {
        generateScreenInfo || {
            ROOT="$(lsw -r)"
            SW=$(wattr w "$ROOT")
            SH=$(wattr h "$ROOT")
            return 1
        }
    }

    screen=$(getCurrentScreen)
    SW=$(sed "/$screen/!d" "$SCREENS" | cut -d\  -f 4)
    SH=$(sed "/$screen/!d" "$SCREENS" | cut -d\  -f 5)
}

# test if a point is over the top of a window
underneath() {
    test $# -eq 0 && {
        X=$(wmp | cut -d\  -f 1)
        Y=$(wmp | cut -d\  -f 2)
    } || {
        intCheck $1 && X=$1
        intCheck $2 && Y=$2
    }

    # start from the highest stacked window
    for wid in $(lsw | tac); do
        windowX=$(wattr x "$wid")
        windowY=$(wattr y "$wid")

        # we won't get a match if the left and top edges greater than X or Y
        test $windowX -gt $X && continue
        test $windowY -gt $Y && continue

        windowW=$(wattr w "$wid")
        windowH=$(wattr h "$wid")

        # we won't get a match if the right and bottom edges are less than X or Y
        test $((windowX + windowW)) -lt $X && continue
        test $((windowY + windowH)) -lt $Y && continue

        printf '%s\n' "$wid"
        unset -v wid
        return 0
    done
}

moveMouseEnabled() {
    wattr "$1" && {
        wid="$1"
    } || {
        printf '%s\n' "Please enter a valid window id." >&2
        return 1
    }

    # move mouse to the middle of the given window id
    wmp -a $(($(wattr x "$wid") + ($(wattr w "$wid") / 2))) \
           $(($(wattr y "$wid") + ($(wattr h "$wid") / 2)))

    unset -v wid
}

    # window management
###############################################################################

PFW="$(pfw)"
CUR=${2:-"$(pfw)"}

X=$(wattr x "$CUR" 2> /dev/null)
Y=$(wattr y "$CUR" 2> /dev/null)
W=$(wattr w "$CUR" 2> /dev/null)
H=$(wattr h "$CUR" 2> /dev/null)

# multiple monitor support
retrieveScreenValues

ROWS=4
COLS=4

BW=${BW:-1}

# best to keep these as multiples of two
IGAP=${IGAP:-$((20))}
VGAP=${VGAP:-$((20))}
XGAP=${XGAP:-$((20))}
BGAP=${BGAP:-$((20))}
TGAP=${TGAP:-$((40))}

eSW=$((SW - 2*XGAP))
eSH=$((SH - TGAP - BGAP))

minW=$((eSW/COLS - $((COLS - 1))*IGAP/COLS))
minH=$((eSH/ROWS - $((ROWS - 1))*VGAP/ROWS))

ACTIVE=${ACTIVE:-0xD7D7D7}
WARNING=${WARNING:-0xB23450}
INACTIVE=${INACTIVE:-0x737373}

    # other
###############################################################################

# duration of runfyre execution loop
DURATION=60

# set to workspaces or groups -- not finised yet
WORKFLOW="groups"

# set path to your background - omit if you don't want fyre to manage your wall
WALL="$HOME/files/pictures/backs/pluto.png"
# call your background program with args if WALL used
BACK="hsetroot -tile $WALL -gamma 0.5 -blur ${1:-$BLUR}"
# set integer factor to blur background by if wall program uses it
BLUR=0

# mouse gets moved to the middle of the window
MOUSE="false"
# moving over windows automatically focuses them
SLOPPY="true"
